// src/index.ts
/**
 * Cloudflare Worker for managing Claude API access through session keys (SKs).
 * Provides endpoints for users to login (randomly or specifically) and for admins to manage SKs.
 * Utilizes KV storage for email-to-SK mappings and supports optional Sentry integration for error tracking.
 */
import { Toucan } from 'toucan-js'; // Optional: for Sentry error monitoring

// --- Type Definitions ---

/**
 * Defines the environment variables and bindings expected by the Worker.
 * These are configured in the Cloudflare dashboard or via wrangler.toml/wrangler.jsonc.
 */
interface Env {
  /**
   * The KV Namespace used to store the email-to-SK mapping.
   * This is where `EMAIL_TO_SK_MAP` key holds the JSON string of mappings.
   */
  CLAUDE_KV: KVNamespace;
  /**
   * The password required for accessing administrative endpoints (e.g., /api/admin/*).
   * This should be set as a Secret in the Worker's settings.
   */
  ADMIN_PASSWORD: string;
  /**
   * The base URL for the Claude API (e.g., https://claude.ai).
   * Used to construct the final login URL.
   */
  BASE_URL: string;
  /**
   * Optional: Sentry DSN for error reporting and monitoring.
   * If provided, errors will be sent to Sentry.
   */
  SENTRY_DSN?: string;
}

/**
 * Represents the structure of the email to session key mapping stored in KV.
 * Keys are email addresses (string), and values are their corresponding session keys (sk, string).
 */
interface EmailSkMap {
  [email: string]: string;
}

/**
 * Defines the structure of the request body for the /api/login endpoint.
 */
interface LoginRequest {
  /**
   * The mode of login: 'specific' (requires email and unique_name) or 'random'.
   */
  mode: 'specific' | 'random';
  /**
   * Optional: The email address for 'specific' mode login.
   */
  email?: string;
  /**
   * Optional: A unique identifier for the session, required for 'specific' mode.
   * For 'random' mode, this is generated by the worker.
   */
  unique_name?: string;
}

/**
 * Base interface for administrative requests, requiring an admin password.
 */
interface AdminRequestBase {
  /**
   * The password to authenticate administrative actions.
   * Must match the ADMIN_PASSWORD secret.
   */
  admin_password: string;
}

/**
 * Defines the structure for adding a new email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminAddRequest extends AdminRequestBase {
  /**
   * The email address to add or update.
   */
  email: string;
  /**
   * The session key (sk) associated with the email.
   */
  sk: string;
}

/**
 * Defines the structure for deleting an email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminDeleteRequest extends AdminRequestBase {
  /**
   * The email address to delete from the mapping.
   */
  email: string;
}

/**
 * Defines the structure for updating an email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminUpdateRequest extends AdminRequestBase {
  /**
   * The current email address to identify the record to be updated.
   */
  email: string;
  /**
   * Optional: The new email address to replace the old one.
   */
  new_email?: string;
  /**
   * Optional: The new session key to replace the old one.
   */
  new_sk?: string;
}

// --- Helper Functions ---

/**
 * Creates a JSON response with appropriate CORS headers.
 * @param data The data to be stringified into the response body.
 * @param status The HTTP status code for the response (default is 200).
 * @param extraHeaders Additional headers to include in the response.
 * @returns A Response object.
 */
const jsonResponse = (data: any, status = 200, extraHeaders = {}) => {
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*', // Allow all origins
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS', // Allow common methods
    'Access-Control-Allow-Headers': 'Content-Type, Authorization', // Allow necessary headers
    ...extraHeaders,
  };
  return new Response(JSON.stringify(data, null, 2), { status, headers });
};

/**
 * Handles CORS preflight (OPTIONS) requests.
 * @param request The incoming Request object.
 * @returns A Response object with appropriate CORS headers for preflight.
 */
const handleOptions = (request: Request) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  };
  return new Response(null, { headers }); // No body for OPTIONS response
};

/**
 * Sorts an array of email addresses, primarily by domain, then by the local part.
 * @param emails An array of email strings.
 * @returns A new array with sorted email strings.
 */
const sortEmails = (emails: string[]): string[] => {
  return emails.sort((a, b) => {
    const [, domainA = ''] = a.split('@'); // Robust split with default
    const [, domainB = ''] = b.split('@');
    if (domainA !== domainB) {
      return domainA.localeCompare(domainB); // Sort by domain first
    }
    return a.localeCompare(b); // Then by full email
  });
};

/**
 * Retrieves and parses the EMAIL_TO_SK_MAP from KV storage.
 * @param env The Environment object containing the KV namespace.
 * @returns A Promise that resolves to the EmailSkMap object. Returns an empty object if not found or on parse error.
 */
async function getEmailSkMap(env: Env): Promise<EmailSkMap> {
  const mapStr = await env.CLAUDE_KV.get('EMAIL_TO_SK_MAP');
  if (!mapStr) {
    console.log("EMAIL_TO_SK_MAP not found in KV, returning empty map.");
    return {}; // Return an empty object if KV key doesn't exist
  }
  try {
    return JSON.parse(mapStr) as EmailSkMap;
  } catch (e) {
    console.error("Error parsing EMAIL_TO_SK_MAP from KV:", e);
    // Optionally, if Sentry is configured, capture this specific error
    // sentry?.captureException(new Error(`Failed to parse EMAIL_TO_SK_MAP: ${e.message}`));
    return {}; // Return empty on parse error to prevent worker crashes
  }
}

// --- Main Worker Fetch Handler ---
export default {
  /**
   * Handles incoming HTTP requests to the Worker.
   * @param request The incoming Request object.
   * @param env The Environment object with bindings and secrets.
   * @param ctx The ExecutionContext for the request.
   * @returns A Promise that resolves to a Response object.
   */
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Handle CORS preflight requests first
    if (request.method === 'OPTIONS') {
      return handleOptions(request);
    }

    // Initialize Sentry if DSN is provided
    const sentry = env.SENTRY_DSN ? new Toucan({
      dsn: env.SENTRY_DSN,
      context: ctx, // Includes execution context like waitUntil
      request,       // Associates errors with the incoming request
    }) : null;

    try {
      const url = new URL(request.url);

      // --- User Endpoints ---

      // GET /api/emails: Lists available email addresses (sorted)
      if (url.pathname === '/api/emails' && request.method === 'GET') {
        const emailMap = await getEmailSkMap(env);
        const sortedEmails = sortEmails(Object.keys(emailMap));
        return jsonResponse({ emails: sortedEmails });
      }

      // POST /api/login: Handles user login requests (specific or random)
      if (url.pathname === '/api/login' && request.method === 'POST') {
        let body: LoginRequest;
        try {
          body = await request.json();
        } catch (e) {
          sentry?.captureMessage('Invalid JSON body for /api/login', { level: 'warning' });
          return jsonResponse({ error: 'Invalid JSON request body.' }, 400);
        }

        const emailMap = await getEmailSkMap(env);
        let sk: string | undefined;
        let uniqueName: string;
        let selectedEmailForLog: string | undefined; // For logging purposes

        if (body.mode === 'random') {
          const emails = Object.keys(emailMap);
          if (emails.length === 0) {
            sentry?.captureMessage('Login attempt failed: No accounts available for random selection.', { level: 'warning' });
            return jsonResponse({ error: 'No accounts available for random selection' }, 503); // Service Unavailable
          }
          selectedEmailForLog = emails[Math.floor(Math.random() * emails.length)];
          sk = emailMap[selectedEmailForLog];
          uniqueName = `rand_${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`; // More unique random name
        } else if (body.mode === 'specific') {
          if (!body.email || !body.unique_name) {
            return jsonResponse({ error: 'Email and unique_name are required for specific mode' }, 400);
          }
          selectedEmailForLog = body.email;
          sk = emailMap[selectedEmailForLog];
          uniqueName = body.unique_name;
        } else {
          return jsonResponse({ error: 'Invalid login mode specified. Must be \"specific\" or \"random\".' }, 400);
        }

        if (!sk) {
          const errorMessage = `Account for ${selectedEmailForLog || 'random selection'} not found or SK is invalid`;
          console.error(`Login attempt for ${selectedEmailForLog || 'random'} failed: SK not found.`);
          sentry?.captureMessage(errorMessage, { level: 'error', extra: { email: selectedEmailForLog, mode: body.mode } });
          return jsonResponse({ error: errorMessage }, 404); // Not Found
        }

        // Attempt to get OAuth token from Claude API
        const oauthPayload = { session_key: sk, unique_name: uniqueName, expires_in: 86400 }; // 24 hours
        const oauthResponse = await fetch(`${env.BASE_URL}/manage-api/auth/oauth_token`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(oauthPayload),
        });

        if (!oauthResponse.ok) {
          const errorText = await oauthResponse.text();
          const logMessage = `Token exchange failed for ${selectedEmailForLog} (SK preview: ${sk.slice(0,15)}...): ${oauthResponse.status}`;
          console.error(`${logMessage} - Response: ${errorText}`);
          sentry?.captureMessage(logMessage, { level: 'error', extra: { email: selectedEmailForLog, status: oauthResponse.status, response: errorText, request_payload: oauthPayload } });
          // Do not expose detailed errorText to the client unless it's safe
          throw new Error(`Token exchange failed with status ${oauthResponse.status}. Check server logs for details.`);
        }
        
        const oauthData: any = await oauthResponse.json();
        if (!oauthData.login_url) {
            const logMessage = `Token exchange response for ${selectedEmailForLog} missing login_url.`;
            console.error(`${logMessage} - Response: ${JSON.stringify(oauthData)}`);
            sentry?.captureMessage(logMessage, { level: 'error', extra: { email: selectedEmailForLog, response: oauthData }});
            throw new Error('Token exchange successful, but login_url was not returned.');
        }
        return jsonResponse({ login_url: `${env.BASE_URL}${oauthData.login_url}` });
      }

      // --- Admin Endpoints (prefixed with /api/admin) ---
      if (url.pathname.startsWith('/api/admin')) {
        // Centralized admin password extraction and validation for POST, PUT, DELETE
        if (request.method === 'POST' || request.method === 'PUT' || request.method === 'DELETE') {
          let adminRequestData: AdminRequestBase;
          try {
            adminRequestData = await request.clone().json(); // Clone for body re-read if needed
          } catch (e) {
            sentry?.captureMessage('Admin endpoint called with invalid JSON body', { level: 'warning', extra: { path: url.pathname, method: request.method } });
            return jsonResponse({ error: 'Invalid JSON body for admin request.' }, 400);
          }
          if (adminRequestData.admin_password !== env.ADMIN_PASSWORD) {
            sentry?.captureMessage('Admin endpoint unauthorized attempt (password mismatch)', { level: 'warning', extra: { path: url.pathname, method: request.method } });
            return jsonResponse({ error: 'Unauthorized. Invalid admin password.' }, 401);
          }
        }
        
        // GET /api/admin/list: Lists all email-SK pairs (requires admin password as query param)
        if (url.pathname === '/api/admin/list' && request.method === 'GET') {
            const queryAdminPassword = url.searchParams.get('admin_password');
            if (queryAdminPassword !== env.ADMIN_PASSWORD) {
                 sentry?.captureMessage('Admin /list unauthorized attempt (query password mismatch or missing)', { level: 'warning' });
                 return jsonResponse({ error: 'Unauthorized. Admin password required as query parameter.' }, 401);
            }

            const emailMap = await getEmailSkMap(env);
            const sortedEmails = sortEmails(Object.keys(emailMap));
            const listWithIndexAndPreview = sortedEmails.map((email, index) => ({
                index: index + 1,
                email: email,
                sk_preview: emailMap[email] ? `${emailMap[email].slice(0, 10)}...${emailMap[email].slice(-5)}` : "SK_INVALID_OR_MISSING" // Show a safer preview
            }));
            return jsonResponse(listWithIndexAndPreview);
        }

        // POST /api/admin/add: Adds a new email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/add' && request.method === 'POST') {
            const body: AdminAddRequest = await request.json(); // Re-read body, safe as password check cloned
            if (!body.email || !body.sk) {
                return jsonResponse({ error: 'Email and SK are required for adding an account.' }, 400);
            }
            const emailMap = await getEmailSkMap(env);
            if (emailMap[body.email]) {
                return jsonResponse({ error: `Email ${body.email} already exists. Use update if intended.` }, 409); // 409 Conflict
            }
            emailMap[body.email] = body.sk;
            await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
            console.log(`Admin action: Account ${body.email} added successfully.`);
            return jsonResponse({ message: `Account ${body.email} added successfully.` });
        }

        // POST /api/admin/delete: Deletes an email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/delete' && request.method === 'POST') {
             const body: AdminDeleteRequest = await request.json(); // Re-read body
             if (!body.email) {
                 return jsonResponse({ error: 'Email is required for deleting an account.' }, 400);
             }
             const emailMap = await getEmailSkMap(env);
             if (!emailMap[body.email]) {
                 return jsonResponse({ error: `Email ${body.email} not found. Cannot delete.` }, 404);
             }
             delete emailMap[body.email];
             await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
             console.log(`Admin action: Account ${body.email} deleted successfully.`);
             return jsonResponse({ message: `Account ${body.email} deleted successfully.` });
        }

        // POST /api/admin/update: Updates an email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/update' && request.method === 'POST') {
            const body: AdminUpdateRequest = await request.json();
            if (!body.email) {
                return jsonResponse({ error: 'The original email is required to identify the account to update.' }, 400);
            }
            if (!body.new_email && !body.new_sk) {
                return jsonResponse({ error: 'Either new_email or new_sk must be provided to perform an update.' }, 400);
            }

            const emailMap = await getEmailSkMap(env);

            if (!emailMap[body.email]) {
                return jsonResponse({ error: `Account for ${body.email} not found. Cannot update.` }, 404);
            }

            // Check for new_email conflict before proceeding
            if (body.new_email && body.new_email !== body.email && emailMap[body.new_email]) {
                return jsonResponse({ error: `The new email ${body.new_email} already exists. Cannot update.` }, 409);
            }
            
            // Store the original SK before any potential modification
            const originalSk = emailMap[body.email];

            // If renaming the email, we must delete the old entry
            if (body.new_email && body.new_email !== body.email) {
                delete emailMap[body.email];
            }
            
            // Determine the final email key and SK value
            const finalEmail = body.new_email || body.email;
            const finalSk = body.new_sk || originalSk;

            emailMap[finalEmail] = finalSk;

            await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
            console.log(`Admin action: Account ${body.email} updated successfully. New details -> Email: ${finalEmail}, SK updated: ${!!body.new_sk}`);
            return jsonResponse({ message: `Account ${body.email} has been updated successfully.` });
        }
        
        // If an admin path was hit but not any of the specific routes above
        return jsonResponse({ error: 'Admin endpoint not found.' }, 404);

      } // End of /api/admin block

      // Fallback for any other route not matched
      return jsonResponse({ error: 'Not Found. The requested endpoint does not exist.' }, 404);

    } catch (error: any) {
      console.error("Worker encountered an unhandled error:", error.stack || error);
      sentry?.captureException(error); // Capture the full exception with stack trace
      // Return a generic error message to the client
      return jsonResponse({ error: 'An internal server error occurred. Please try again later.' }, 500);
    }
  },
};